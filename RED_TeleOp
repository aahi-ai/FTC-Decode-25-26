package org.firstinspires.ftc.teamcode.pedroPathing;

import com.qualcomm.hardware.limelightvision.LLResult;
import com.qualcomm.hardware.limelightvision.Limelight3A;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.robotcore.external.navigation.YawPitchRollAngles;

@TeleOp(name="RED", group="TeleOp")
public class RED extends LinearOpMode {

    // Drivetrain motors
    private DcMotor leftFront, rightFront, leftBack, rightBack;

    // Mechanisms
    private DcMotor intake;
    private DcMotor turret;
    private DcMotorEx shooter1, shooter2;
    private Servo gate;

    // Limelight and IMU
    private Limelight3A limelight;
    private IMU imu;

    // Drive max speed (0.0 to 1.0)
    private static final double MAX_SPEED = 1.0;

    // Mechanism powers
    private static final double INTAKE_POWER  = 1.0;
    private static final double TURRET_MANUAL_POWER = 0.25;  // CHANGED: reduced from 0.6 to 0.25
    private static final double TRIGGER_THRESH = 0.5;

    // Turret auto-tracking
    private static final double DEADZONE = 2.0;

    // PID Constants
    private static final double Kp = 0.001;
    private static final double Ki = 0.0002;
    private static final double Kd = 0.00005;

    // Your measured max velocity at full power
    private static final double MAX_VELOCITY = 2000;

    // Shooter speed (adjustable from 0.0 to 1.0)
    private double shooterSpeed = 0.5;

    // Target velocities
    private double targetVelocity1 = 0;
    private double targetVelocity2 = 0;

    // PID variables
    private double integralSum1 = 0;
    private double integralSum2 = 0;
    private double lastError1 = 0;
    private double lastError2 = 0;
    private ElapsedTime pidTimer = new ElapsedTime();

    // Intake state machine
    private enum IntakeState { OFF, FORWARD, REVERSE }
    private IntakeState intakeState = IntakeState.FORWARD;  // CHANGED: start in FORWARD state
    private boolean prevRB1 = false;
    private boolean prevLB1 = false;

    // Gate servo management
    private boolean prevA1 = false;
    private ElapsedTime gateTimer = new ElapsedTime();
    private boolean gateMoving = false;

    // Shooter management
    private boolean shootersOn = true;  // CHANGED: start with shooters ON
    private boolean prevRT1 = false;
    private boolean prevLT1 = false;

    // Gamepad 2 controls
    private boolean prevA2 = false;
    private boolean prevB2 = false;

    @Override
    public void runOpMode() {

        // Initialize drive motors
        leftBack = hardwareMap.get(DcMotor.class, "leftBack");
        leftFront = hardwareMap.get(DcMotor.class, "leftFront");
        rightBack = hardwareMap.get(DcMotor.class, "rightBack");
        rightFront = hardwareMap.get(DcMotor.class, "rightFront");

        // Initialize mechanisms (use DcMotorEx for velocity control)
        intake   = hardwareMap.get(DcMotor.class, "intake");
        turret   = hardwareMap.get(DcMotor.class, "turret");
        shooter1 = hardwareMap.get(DcMotorEx.class, "shooter1");
        shooter2 = hardwareMap.get(DcMotorEx.class, "shooter2");
        gate     = hardwareMap.get(Servo.class, "gate");

        // Initialize Limelight
        limelight = hardwareMap.get(Limelight3A.class, "limelight");
        limelight.pipelineSwitch(0);

        // Initialize IMU
        imu = hardwareMap.get(IMU.class, "imu");
        RevHubOrientationOnRobot revHubOrientationOnRobot = new RevHubOrientationOnRobot(
                RevHubOrientationOnRobot.LogoFacingDirection.RIGHT,
                RevHubOrientationOnRobot.UsbFacingDirection.UP);
        imu.initialize(new IMU.Parameters(revHubOrientationOnRobot));

        // Directions
        leftFront.setDirection(DcMotor.Direction.FORWARD);
        leftBack.setDirection(DcMotor.Direction.REVERSE);
        rightFront.setDirection(DcMotor.Direction.REVERSE);
        rightBack.setDirection(DcMotor.Direction.FORWARD);

        intake.setDirection(DcMotor.Direction.FORWARD);
        turret.setDirection(DcMotor.Direction.FORWARD);
        shooter1.setDirection(DcMotor.Direction.REVERSE);
        shooter2.setDirection(DcMotor.Direction.FORWARD);

        // Brake mode for better control
        leftFront.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        rightFront.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        leftBack.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        rightBack.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        intake.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        turret.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        shooter1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        shooter2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);

        // Motor modes
        intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        turret.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        // Shooters use encoders for PID velocity control
        shooter1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        shooter2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        shooter1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        shooter2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // CHANGED: Start intake and shooters immediately
        intake.setPower(INTAKE_POWER);
        turret.setPower(0);
        gate.setPosition(0.0);

        telemetry.addLine("BLUE - Auto-Start Mode");
        telemetry.addLine("GP1: RB=intake cycle, LB=stop, A=gate pulse");
        telemetry.addLine("GP1: RT=shooters on, LT=shooters off");
        telemetry.addLine("GP2: RB/LB=manual turret (0.25 power), A/B=speed adjust");
        telemetry.addLine("Shooters & Intake START AUTOMATICALLY!");
        telemetry.update();

        waitForStart();
        limelight.start();
        pidTimer.reset();

        // CHANGED: Initialize shooters to start spinning immediately
        targetVelocity1 = MAX_VELOCITY * shooterSpeed;
        targetVelocity2 = MAX_VELOCITY * shooterSpeed;
        integralSum1 = 0;
        integralSum2 = 0;
        lastError1 = 0;
        lastError2 = 0;

        while (opModeIsActive()) {
            // =======================
            // Drivetrain (gamepad1)
            // =======================
            double drive = gamepad1.left_stick_y;
            double strafe = gamepad1.left_stick_x;
            double turn = -gamepad1.right_stick_x;

            double leftFrontPower = drive + strafe + turn;
            double rightFrontPower = drive - strafe - turn;
            double leftBackPower = drive - strafe + turn;
            double rightBackPower = drive + strafe - turn;

            double max = Math.max(1.0, Math.max(Math.max(
                            Math.abs(leftFrontPower), Math.abs(rightFrontPower)),
                    Math.max(Math.abs(leftBackPower), Math.abs(rightBackPower))));

            leftFront.setPower((leftFrontPower / max) * MAX_SPEED);
            rightFront.setPower((rightFrontPower / max) * MAX_SPEED);
            leftBack.setPower((leftBackPower / max) * MAX_SPEED);
            rightBack.setPower((rightBackPower / max) * MAX_SPEED);

            // =======================
            // Intake (gamepad1 bumpers)
            // =======================
            boolean rb1 = gamepad1.right_bumper;
            boolean lb1 = gamepad1.left_bumper;

            // Right bumper cycles through intake states
            if (rb1 && !prevRB1) {
                switch (intakeState) {
                    case OFF:
                        intakeState = IntakeState.FORWARD;
                        break;
                    case FORWARD:
                        intakeState = IntakeState.REVERSE;
                        break;
                    case REVERSE:
                        intakeState = IntakeState.FORWARD;
                        break;
                }
                applyIntakePower();
            }

            // Left bumper stops intake
            if (lb1 && !prevLB1) {
                intakeState = IntakeState.OFF;
                applyIntakePower();
            }

            prevRB1 = rb1;
            prevLB1 = lb1;

            // =======================
            // Gate servo pulse (gamepad1.a)
            // =======================
            boolean a1 = gamepad1.a;

            if (a1 && !prevA1 && !gateMoving) {
                gate.setPosition(1.0);
                gateTimer.reset();
                gateMoving = true;
            }

            // Return gate to position 0 after 1.5 seconds
            if (gateMoving && gateTimer.seconds() >= 1.5) {
                gate.setPosition(0.0);
                gateMoving = false;
            }

            prevA1 = a1;

            // =======================
            // Shooters (gamepad1 triggers)
            // =======================
            boolean rt1 = gamepad1.right_trigger > TRIGGER_THRESH;
            boolean lt1 = gamepad1.left_trigger > TRIGGER_THRESH;

            // Start shooters with right trigger
            if (rt1 && !prevRT1) {
                shootersOn = true;
                targetVelocity1 = MAX_VELOCITY * shooterSpeed;
                targetVelocity2 = MAX_VELOCITY * shooterSpeed;
                integralSum1 = 0;
                integralSum2 = 0;
                lastError1 = 0;
                lastError2 = 0;
                pidTimer.reset();
            }

            // Stop shooters with left trigger
            if (lt1 && !prevLT1) {
                shootersOn = false;
                shooter1.setPower(0);
                shooter2.setPower(0);
                targetVelocity1 = 0;
                targetVelocity2 = 0;
            }

            prevRT1 = rt1;
            prevLT1 = lt1;

            // =======================
            // TURRET CONTROL (Auto + Manual)
            // =======================
            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();
            limelight.updateRobotOrientation(orientation.getYaw());
            LLResult llResult = limelight.getLatestResult();

            boolean tagDetected = (llResult != null && llResult.isValid());
            double turretCmd = 0.0;

            if (tagDetected) {
                // AUTO TRACKING when AprilTag detected
                double tx = llResult.getTx();
                turretCmd = tx * 0.03;
                turretCmd = Math.max(-0.6, Math.min(0.6, turretCmd));
                if (Math.abs(tx) < DEADZONE) {
                    turretCmd = 0;
                }
            } else {
                // MANUAL CONTROL when no tag (gamepad2)
                boolean rb2 = gamepad2.right_bumper;
                boolean lb2 = gamepad2.left_bumper;

                if (rb2) {
                    turretCmd = TURRET_MANUAL_POWER;  // Rotate right (0.25 power)
                } else if (lb2) {
                    turretCmd = -TURRET_MANUAL_POWER; // Rotate left (0.25 power)
                }
            }

            turret.setPower(turretCmd);

            // =======================
            // Speed Adjustment (gamepad2)
            // =======================
            boolean a2 = gamepad2.a;
            boolean b2 = gamepad2.b;

            // Increase shooter speed by 0.01
            if (a2 && !prevA2) {
                shooterSpeed = Math.min(1.0, shooterSpeed + 0.01);
                if (shootersOn) {
                    targetVelocity1 = MAX_VELOCITY * shooterSpeed;
                    targetVelocity2 = MAX_VELOCITY * shooterSpeed;
                }
            }

            // Decrease shooter speed by 0.01
            if (b2 && !prevB2) {
                shooterSpeed = Math.max(0.0, shooterSpeed - 0.01);
                if (shootersOn) {
                    targetVelocity1 = MAX_VELOCITY * shooterSpeed;
                    targetVelocity2 = MAX_VELOCITY * shooterSpeed;
                }
            }

            prevA2 = a2;
            prevB2 = b2;

            // =======================
            // PID Control Loop
            // =======================
            double power1 = 0, power2 = 0;
            double vel1 = 0, vel2 = 0;
            double error1 = 0, error2 = 0;

            if (shootersOn && targetVelocity1 > 0) {
                vel1 = Math.abs(shooter1.getVelocity());
                vel2 = Math.abs(shooter2.getVelocity());

                double dt = pidTimer.seconds();
                pidTimer.reset();

                if (dt == 0 || dt > 0.1) dt = 0.02;

                // SHOOTER 1 PID
                error1 = targetVelocity1 - vel1;
                double derivative1 = (error1 - lastError1) / dt;
                integralSum1 += error1 * dt;
                integralSum1 = Math.max(-500, Math.min(500, integralSum1));

                power1 = (Kp * error1) + (Ki * integralSum1) + (Kd * derivative1);
                power1 = Math.max(0, Math.min(1.0, power1));

                lastError1 = error1;

                // SHOOTER 2 PID
                error2 = targetVelocity2 - vel2;
                double derivative2 = (error2 - lastError2) / dt;
                integralSum2 += error2 * dt;
                integralSum2 = Math.max(-500, Math.min(500, integralSum2));

                power2 = (Kp * error2) + (Ki * integralSum2) + (Kd * derivative2);
                power2 = Math.max(0, Math.min(1.0, power2));

                lastError2 = error2;

                shooter1.setPower(power1);
                shooter2.setPower(power2);
            }

            // =======================
            // Telemetry
            // =======================
            telemetry.addData("Drive (LF RF LB RB)",
                    "%.2f  %.2f  %.2f  %.2f",
                    leftFront.getPower(), rightFront.getPower(),
                    leftBack.getPower(), rightBack.getPower());

            telemetry.addData("Intake",
                    "%s (power=%.1f)",
                    intakeState.name(), intake.getPower());

            telemetry.addData("Gate", "Position=%.2f %s",
                    gate.getPosition(),
                    gateMoving ? "(PULSING)" : "");

            if (tagDetected) {
                telemetry.addData("Turret", "AUTO TRACKING (Tx=%.2f, Power=%.2f)",
                        llResult.getTx(), turretCmd);
            } else {
                telemetry.addData("Turret", "MANUAL MODE (Power=%.2f)", turretCmd);
            }

            telemetry.addLine();
            telemetry.addData("Shooters", "on=%s  speed=%.3f",
                    shootersOn ? "YES" : "NO", shooterSpeed);
            telemetry.addData("S1", "target=%.0f  actual=%.0f  pwr=%.2f",
                    targetVelocity1, vel1, power1);
            telemetry.addData("S2", "target=%.0f  actual=%.0f  pwr=%.2f",
                    targetVelocity2, vel2, power2);

            boolean atTarget = Math.abs(error1) < 100 && Math.abs(error2) < 100;
            telemetry.addData("Ready", atTarget ? "YES âœ“" : "NO");

            telemetry.update();
        }

        limelight.stop();
    }

    // Helper: apply intake power from current state
    private void applyIntakePower() {
        switch (intakeState) {
            case OFF:
                intake.setPower(0.0);
                break;
            case FORWARD:
                intake.setPower(+INTAKE_POWER);
                break;
            case REVERSE:
                intake.setPower(-INTAKE_POWER);
                break;
        }
    }
}
