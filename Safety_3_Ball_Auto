package org.firstinspires.ftc.teamcode.pedroPathing;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.util.ElapsedTime;

@Autonomous(name="Back Auto", group="Autonomous")
public class Blue_3 extends LinearOpMode {

    // Mechanisms
    private DcMotor intake;
    private DcMotorEx shooter1, shooter2;

    // Constants
    private static final double SHOOTER_SPEED = 0.75;
    private static final double MAX_VELOCITY = 2000;
    private static final double INTAKE_POWER = 1.0;

    // PID Constants
    private static final double Kp = 0.001;
    private static final double Ki = 0.0002;
    private static final double Kd = 0.00005;

    // PID variables
    private double integralSum1 = 0;
    private double integralSum2 = 0;
    private double lastError1 = 0;
    private double lastError2 = 0;
    private ElapsedTime pidTimer = new ElapsedTime();

    @Override
    public void runOpMode() {

        // Initialize mechanisms
        intake = hardwareMap.get(DcMotor.class, "intake");
        shooter1 = hardwareMap.get(DcMotorEx.class, "shooter1");
        shooter2 = hardwareMap.get(DcMotorEx.class, "shooter2");

        // Set directions
        intake.setDirection(DcMotor.Direction.FORWARD);
        shooter1.setDirection(DcMotor.Direction.REVERSE);
        shooter2.setDirection(DcMotor.Direction.FORWARD);

        // Zero power behaviors
        intake.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        shooter1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        shooter2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);

        // Motor modes
        intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        // Shooters use encoders for velocity control
        shooter1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        shooter2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        shooter1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        shooter2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // Ensure everything is stopped
        intake.setPower(0);
        shooter1.setPower(0);
        shooter2.setPower(0);

        telemetry.addLine("Autonomous Ready");
        telemetry.addLine("Sequence:");
        telemetry.addLine("1. Start shooters at 0.66 speed");
        telemetry.addLine("2. Wait 6 seconds");
        telemetry.addLine("3. Run intake for 2 seconds");
        telemetry.addLine("4. Stop all motors");
        telemetry.update();

        waitForStart();

        if (opModeIsActive()) {
            // Calculate target velocities
            double targetVelocity = MAX_VELOCITY * SHOOTER_SPEED;

            telemetry.addLine("Starting shooters...");
            telemetry.update();

            // Start shooters with PID control
            pidTimer.reset();
            ElapsedTime sequenceTimer = new ElapsedTime();
            sequenceTimer.reset();

            // Run shooters for the entire sequence (8+ seconds)
            while (opModeIsActive() && sequenceTimer.seconds() < 8.0) {
                // PID control for shooters
                double vel1 = Math.abs(shooter1.getVelocity());
                double vel2 = Math.abs(shooter2.getVelocity());

                double dt = pidTimer.seconds();
                pidTimer.reset();
                if (dt == 0 || dt > 0.1) dt = 0.02;

                // SHOOTER 1 PID
                double error1 = targetVelocity - vel1;
                double derivative1 = (error1 - lastError1) / dt;
                integralSum1 += error1 * dt;
                integralSum1 = Math.max(-500, Math.min(500, integralSum1));

                double power1 = (Kp * error1) + (Ki * integralSum1) + (Kd * derivative1);
                power1 = Math.max(0, Math.min(1.0, power1));
                lastError1 = error1;

                // SHOOTER 2 PID
                double error2 = targetVelocity - vel2;
                double derivative2 = (error2 - lastError2) / dt;
                integralSum2 += error2 * dt;
                integralSum2 = Math.max(-500, Math.min(500, integralSum2));

                double power2 = (Kp * error2) + (Ki * integralSum2) + (Kd * derivative2);
                power2 = Math.max(0, Math.min(1.0, power2));
                lastError2 = error2;

                shooter1.setPower(power1);
                shooter2.setPower(power2);

                // Handle intake timing (start at 6 seconds, stop at 8 seconds)
                if (sequenceTimer.seconds() >= 6.0 && sequenceTimer.seconds() < 8.0) {
                    intake.setPower(INTAKE_POWER);
                }

                // Telemetry
                telemetry.addData("Time Elapsed", "%.1f seconds", sequenceTimer.seconds());
                telemetry.addData("Shooter 1", "Target: %.0f | Actual: %.0f | Power: %.2f",
                        targetVelocity, vel1, power1);
                telemetry.addData("Shooter 2", "Target: %.0f | Actual: %.0f | Power: %.2f",
                        targetVelocity, vel2, power2);

                if (sequenceTimer.seconds() < 3.0) {
                    telemetry.addLine("Status: Waiting to start intake...");
                } else if (sequenceTimer.seconds() < 8.0) {
                    telemetry.addLine("Status: INTAKE RUNNING");
                } else {
                    telemetry.addLine("Status: Stopping...");
                }

                telemetry.update();
            }

            // Stop all motors
            intake.setPower(0);
            shooter1.setPower(0);
            shooter2.setPower(0);

            telemetry.addLine("Sequence Complete - All motors stopped");
            telemetry.update();

            sleep(1000); // Brief pause to show completion message
        }
    }
}
